<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>OnlyT Timers</title>
    <style type="text/css">
        html {
            background: #000000;
            display: block;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            display: table;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        .main {
            display: table-cell;
            width: 100%;
            height: 100%;
            text-align: center;
            vertical-align: middle;
        }

        .clockstyle {
            font-family: sans-serif;
            font-weight: bold;
            color: #FFFFFF;
            font-kerning: none;
        }

        .clockstyle_yellow {
            font-family: sans-serif;
            font-weight: bold;
            color: #FFFF66;
        }

        .clockstyle_green {
            font-family: sans-serif;
            font-weight: bold;
            color: #00FF00;
        }

        .clockstyle_red {
            font-family: sans-serif;
            font-weight: bold;
            color: #FF0000;
        }

        .clockstyle_dim {
            font-family: sans-serif;
            color: #668080;
        }

        .link_container {
            display: table-row;
            width: 100%;
            text-align: right;
            padding: 5px;
        }

        dl.talk_info {
            font-size: 2em;
            color: #ffffff;
            width: 80%;
            overflow: hidden;
            margin: 0 auto;
            float: right;
            margin-bottom: 10px;
            margin-top: 10px;
        }

        .talk_info dt {
            float: left;
            width: 45%;
            text-align: left;
        }
        
        .talk_info dd {
            float: left;
            width: 20%;
            text-align: right;
        }

        a,
        a:visited {
            color: blue;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div id="main" class="main">
        <span id="maintext" onclick="location.reload(); return false" style="display:none"></span>
    </div>
    <div class="link_container"><a href="./index">{WEB_LINK_CLOCK}</a></div>

    <script type="text/javascript">
        "use strict";

        const mainDiv = document.getElementById("main");
        const textElem = document.getElementById("maintext");
        const textNode = document.createTextNode("");
        textElem.appendChild(textNode);

        let currentMode = "Nameplate";
        let currentDisplayMode = "Nameplate";
        let currentTargetSecs = 0;
        let currentlyCountingUp = false;
        let timerStartDateTime = new Date();
        let modeTransition = false;
        let POLLING_INTERVAL_SECS = 4;
        let currentTalk = null;
        let timersLoaded = false;

        function getOnlyTJson() {
            let clientDate = new Date();

            let myGetRequest = new XMLHttpRequest();
            myGetRequest.overrideMimeType("application/json");

            myGetRequest.onreadystatechange = function () {
                let responseDate = new Date();

                if (myGetRequest.readyState == 4) {
                    if ((myGetRequest.status == 200 || window.location.href.indexOf("http") == -1) && !!myGetRequest.responseText) {
                        const jsondata = JSON.parse(myGetRequest.responseText);

                        if (!timersLoaded) {
                            const keys = ["talkId", "talkTitle"];
                            const talkHtml = `<dl class="talk_info" id="talk_{${keys[0]}}"><dt>{${keys[1]}}</dt><dd>{timer}</dd></dl>`;
                            // Load the timers list
                            const parts = [];
                            for (var i = 0; i < jsondata.timerInfo.length; i++) {
                                const timerInfo = jsondata.timerInfo[i];
                                let currPart = talkHtml;
                                keys.forEach(k => currPart = currPart.replace(`{${k}}`, timerInfo[k]));
                                const totalUsedSecs = (timerInfo.adaptedDurationSecs || timerInfo.originalDurationSecs) - timerInfo.completedTimeSecs;
                                const minutes = Math.floor(totalUsedSecs / 60);
                                const seconds = totalUsedSecs - (minutes * 60);
                                currPart = currPart.replace('{timer}', `${("0" + minutes).slice(-2)}:${("0" + seconds).slice(-2)}`);
                                parts.push(currPart);
                            }
                            const div = document.createElement("div");
                            div.id = "timers";
                            div.innerHTML = parts.join("\n");
                            mainDiv.appendChild(div);
                            timersLoaded = true;
                        }

                        if (jsondata.status.isRunning) {
                            currentMode = "Timer";
                            const requestLatencyMillisecs = responseDate.getTime() - clientDate.getTime();
                            const timerElapsedMillisecs = getClientTimerElapsedMilliSecs();

                            const currentTalkData = jsondata.timerInfo.find(t => t.talkId === jsondata.status.talkId);
                            currentTalk = document.getElementById(`talk_${currentTalkData.talkId}`);
                            const timeElapsedParts = jsondata.status.timeElapsed.split(":");
                            const currentTimerHours = parseInt(timeElapsedParts[0]);
                            const currentTimerMins = parseInt(timeElapsedParts[1]) + (currentTimerHours * 60);
                            const currentTimerSecs = parseFloat(timeElapsedParts[2]);
                            currentTargetSecs = parseInt(jsondata.status.targetSeconds);
                            currentlyCountingUp = currentTalkData.countUp;

                            const serverTimerElapsedMillisecs = (currentTimerMins * 60000) + (currentTimerSecs * 1000);
                            const diffMillisecs = serverTimerElapsedMillisecs - timerElapsedMillisecs + (requestLatencyMillisecs / 2);

                            if (Math.abs(diffMillisecs) > 100) {
                                // client timer out by more than 1/10 sec so adjust the timerStart
                                timerStartDateTime.setTime(timerStartDateTime.getTime() - diffMillisecs);
                                console.log("timer adjustment: " + diffMillisecs + "ms")
                            }
                        } else {
                            currentTalk = null;
                            currentMode = "Timers";
                        }
                    }
                    else {
                        currentMode = "Offline";
                    }
                }
            }

            myGetRequest.ontimeout = function (e) {
                currentMode = "Offline";
                console.log("timeout");
            };

            let url = "../api/v3/timers?" + clientDate.getTime();	// unique uri to prevent reuse of cached json
            myGetRequest.open("GET", url, true);
            myGetRequest.timeout = 2000;
            myGetRequest.send(null);

            setTimeout(getOnlyTJson, POLLING_INTERVAL_SECS * 1000);
        }

        function getClientTimerElapsedMilliSecs() {
            const milliSecsNow = new Date().getTime();
            const clientStartMilliSecs = timerStartDateTime.getTime();
            return (milliSecsNow - clientStartMilliSecs);
        }

        function formatMajorMinor(major, minor) {
            let s = "";
            s += (major < 10 ? "0" : "") + major + ":";
            s += (minor < 10 ? "0" : "") + minor;
            return s;
        }

        function setClockColour(remainingSecs) {
            if (remainingSecs <= 0) {
                textElem.className = "clockstyle_red";
            }

            else if (remainingSecs <= 30) {
                textElem.className = "clockstyle_yellow";
            }

            else {
                textElem.className = "clockstyle_green";
            }
        }

        function conditionalUpdateTxtSize() {
            if (modeTransition) {
                updateTextSize();
            }
        }

        function getDisplayString() {
            modeTransition = (currentDisplayMode != currentMode);

            switch (currentMode) {
                case "Timers":
                    textElem.style.display = "none";
                    document.getElementById("timers").style.display = "";
                    return "";

                case "Timer":
                    textElem.style.display = "none";
                    document.getElementById("timers").style.display = "";
                    const clientTimerTotalElapsedSecs = getClientTimerElapsedMilliSecs() / 1000;
                    const remainingSecs = currentTargetSecs - clientTimerTotalElapsedSecs;

                    setClockColour(remainingSecs);
                    currentDisplayMode = currentMode;

                    return currentlyCountingUp
                        ? getTimeDisplayStringCountingUp(clientTimerTotalElapsedSecs)
                        : getTimeDisplayStringCountingDown(clientTimerTotalElapsedSecs, currentTargetSecs);

                default:
                    if (!!textElem.style.display) {
                        textElem.style.display = "";
                        updateTextSize();
                    }
                    if (timersLoaded) {
                        document.getElementById("timers").remove();
                    }
                    currentTalk = null;
                    timersLoaded = false;
                    currentDisplayMode = currentMode;
                    textElem.className = "clockstyle_dim";
                    return currentMode !== "Nameplate" ? "{WEB_OFFLINE}" : "OnlyT";
            }
        }

        function getTimeDisplayStringCountingUp(elapsedSecs) {
            let integralSecs = Math.abs(Math.floor(elapsedSecs % 60));
            let integralMins = Math.abs(Math.floor(elapsedSecs / 60));

            if (integralSecs === 60) {
                integralSecs = 0;
                ++integralMins;
            }

            return formatMajorMinor(integralMins, integralSecs);
        }

        function getTimeDisplayStringCountingDown(elapsedSecs, targetSecs) {
            let remainingSecs = targetSecs - elapsedSecs;
            let integralSecs = Math.abs(Math.ceil(remainingSecs % 60));
            let integralMins = Math.abs(Math.floor(remainingSecs / 60));

            if (integralSecs === 60) {
                integralSecs = 0;
                ++integralMins;
            }

            if (remainingSecs < 0 && integralMins > 0) {
                --integralMins;
            }

            return formatMajorMinor(integralMins, integralSecs);
        }

        function updateTimer() {
            let s = getDisplayString();
            if (s != "stet") {
                if (!!currentTalk) {
                    currentTalk.getElementsByTagName("dd")[0].innerHTML = s;
                } else {
                    textNode.data = s;
                }
            }

            conditionalUpdateTxtSize();
            setTimeout(updateTimer, 100);	// every 1/10 sec
        }

        function updateTextSize() {
            let curFontSize = 24;
            const targetWidth = 0.9;  // Proportion of full screen width
            for (let i = 0; i < 3; i++) {
                // Iterate for better better convergence
                const newFontSize = mainDiv.offsetWidth * targetWidth / textElem.offsetWidth * curFontSize;
                textElem.style.fontSize = newFontSize.toFixed(3) + "pt";
                curFontSize = newFontSize;
            }
        }

        getOnlyTJson();
        updateTimer();
        updateTextSize();

        window.addEventListener("resize", updateTextSize);
    </script>
</body>
</html>
